# -*- coding: utf-8 -*-
"""ML_Assignment3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1omsrfvWk_46lYJv7TN5k2riKLgMJFAr4

Submitted by: **Shaiva Muthaiyah**

# FML Lab Assignment: 3

# 1. Creating a matrix using numpy.matrix function
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

M = np.matrix([[86,137.8],[43,69],[61,97.8],[43,69],[67,107.4],[8,13],[51,81.8],[100,160.2],[19,30.6],[78,125]])
print(M)

"""# 2. Define a function hypo(t0,t1, X), that takes 3 parameters, t0,t1, X
where X is the first column of the matrix, M. i.e. M1

"""

import numpy as np
import matplotlib.pyplot as plt

M = np.matrix([[86, 137.8], [43, 69], [61, 97.8], [43, 69], [67, 107.4], [8, 13], [51, 81.8], [100, 160.2], [19, 30.6], [78, 125]])

# Extracting the first column (M1) as a 1D array
X = np.squeeze(np.array(M[:, 0]))


# Hypo function that takes three parameters
def hypo(t0, t1, X):
    Yp = t0 + t1 * X
    return Yp

# Example parameters
t0 = 3
t1 = 5

Yp = hypo(t0, t1, X)

print(Yp)

plt.scatter(X, Yp, label='Yp')
plt.xlabel('M1')
plt.ylabel('Yp')
plt.title('Hypothesis Function')
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Create a square matrix which is capable of inversion
M = np.matrix([[86, 137.8]])

# Extract first column M1
M1 = M[:, 0]

# Extract second column M2 as target value
M2 = M[:, 1]

# Hypo function that takes three parameters
def hypo(t0, t1, X):
    Yp = t0 + t1 * X
    return Yp

# Number of samples m
m = len(M1)

t0 = 0

# Cost function that takes m, t1, M1 and M2
def cost_function(t1, M1, M2):
    error = hypo(t0, t1, M1) - M2
    cost = (1 / (2 * len(M1))) * np.sum(error**2)
    return cost

# Example values of t1 to plot
t1_values = [0.1, 0.3, 0.5, 0.7, 0.8]

# Calculate J for each value of t1
J_values = [cost_function(t1, M1, M2) for t1 in t1_values]

# Plotting the graph
plt.plot(t1_values, J_values, marker='o')
plt.xlabel('t1')
plt.ylabel('J_Values')
plt.title('Cost Function vs. t1')
plt.show()

"""# 3. Implement Linear regression, using inbuilt package


"""

from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split

# Load dataset petrol_consumption.csv
df = pd.read_csv("/content/petrol_consumption.csv")
# Display the first few rows of the dataset to understand its structure
print(df.head())

# Initialize the MinMaxScaler
scaler = MinMaxScaler()

# Extract features (X) and target variable (y)
X = df.drop('Petrol_Consumption', axis=1)
y = df['Petrol_Consumption']

# Normalize the datafram
X_normalized = pd.DataFrame(scaler.fit_transform(X), columns=X.columns)

# Display the normalized features
print(X_normalized.head())

# Split the dataset into training and test data
X_train, X_test, y_train, y_test = train_test_split(X_normalized, y, test_size=0.2, random_state=0)

"""Training the Model using the training data X_train and y_train"""

from sklearn.linear_model import LinearRegression

# Create regression object from the package which will help create model
regressor = LinearRegression()

# Train the model using the split dataset
regressor.fit(X_train, y_train)

"""Predict the target values based on the test data X"""

# Predicting the value of Y using the X_test data
y_pred = regressor.predict(X_test)
print(y_pred)

"""Implement Mean Squared Error"""

from sklearn.metrics import mean_squared_error

# Calculate mean squared error using the method
mse = mean_squared_error(y_test, y_pred)

print(f"Mean Squared Error (MSE): {mse}")